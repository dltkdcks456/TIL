![image-20230314224709959](assets/image-20230314224709959.png)

> 개발자가 작성한 HTML을 브라우저가 전달받으면, 브라우저의 렌더 엔진이 이를 파싱하고 DOM node로 이루어진 트리를 생성합니다. 이후 CSS 파일과 각 엘리먼트의 inline 스타일을 파싱하고 스타일 정보를 추가하여 렌더트리를 생성합니다. 렌더트리가 만들어지고 나면 레이아웃 과정을 거칩니다. 이 과정에서 각 노드들은 스크린의 좌표가 주어지고 정확히 어디에 위치해야 할 지가 정해집니다. 마지막으로 painting과정이 실행된다 . 앞선 과정에서 얻을 수 있는 정보들로 모든 요소들에 색을 입히는 과정입니다. 이 과정을 거치고 나면 화면에 UI가 렌더됩니다. 

```
DOM을 직접 조작하여 화면을 업데이트하려면 앞서 설명했던 HTML, CSS 파싱부터 화면에 Painting하는 과정까지 전부 진행하게 되어 비효율적인 부분이 발생한다. 실제로 많으 연산을 수반하고 비용이 많이 드는 작업이어서 프로그램 성능이 저하된다.
```

### SSR

![image-20230314225052460](assets/image-20230314225052460.png)

> 예전에는 서버에서 데이터와 함께 완전한 페이지를 렌더해주는 서버사이드렌더링 방식을 많이 사용했습니다. 원래 DOM은 정적인 페이지를 보여주는데 많이 사용됐기 때문에  DOM의 동적인 변화가 그렇게 큰 문제가 되지 않았다.

![image-20230314225203690](assets/image-20230314225203690.png)

> 하지만 SPA

![image-20230314225317758](assets/image-20230314225317758.png)

![](assets/image-20230314225340023.png)

![image-20230314225527768](assets/image-20230314225527768.png)

> Virtual DOM은 실제 DOM node tree를 복제한 자바스크립트 객체입니다. 

![image-20230314225612633](assets/image-20230314225612633.png)

> virtual DOM은 실제 DOM과 같은 class, style 등의 속성들을 갖고 있지만 화면에 변화를 직접 줄 수 있는 기능인 getElementById 등과 같은 DOM api들은 갖고 있지 않다. 

![image-20230314225722257](assets/image-20230314225722257.png)

> 최초에 브라우저가 실제 DOM 트리를 생성하고 브라우저 화면에 우리의 애플리케이션 UI가 렌더됩니다. 이때 virtual DOM은 DOM 트리를 가벼운 버전으로 복사를 한다. 

![image-20230314225814974](assets/image-20230314225814974.png)

> 그리고 DOM 노드에 변화가 생기면 Virtual DOM은 다시 새로운 가상의 DOM 트리를 처음부터 다시 만들게 됩니다. 이 과정에서 변화가 생길 때마다 새로운 DOM트리를 만드는 것이 비효율적이라고 생각이 들 수 있다. 하지만 DOM 노드를 조작하는 것의 비효율성은 DOM 트리를 업데이트하는 과정에서 발생하는 것이 아니라 렌더링하는 과정에서 비싼 비용이 드는 것이다. 하지만 virtual DOM은 렌더링을 하지 않고 메모리 상에서 트리를 변경하는 일이기 때문에 상당히 빠르게 작업이 진행될 수 있습니다. 

![image-20230314230016334](assets/image-20230314230016334.png)

![image-20230314230050398](assets/image-20230314230050398.png)

> diff 함수에서 매개변수로 이전 상태의 DOM트리와 새롭게 만들어진 DOM트리를 각각 previous, current라는 이름으로 받아온다. 이 함수를 통해서 변경 전의 돔트리와 변경 후의 돔트리의 변화된 부분만을 확인하게 됩니다. 