# 07-26 수업

### 재귀함수

- 함수(main이 실행되고 함수가 실행)
  - 함수, 변수, return, 돌아가야할 위치를 불러와서 실행
  - main(메모리있음)이 아닌 함수가 가진 메모리로 들어감
- 탈출 코드가 필요

- `fib(5)  fib(4) + fib(3)` 에서  `fib(4)`를 전부 리턴한 다음에 `fib(3)`을 시작
  - return하고 값을 메모리에서 삭제해버림. 다시 계산하게 됨.
  - 끝난 계산식을 저장하면 소요 시간을 줄일 수 있다
  - 기본적으로 재귀함수는 시간이 오래 걸린다(시간복잡도가 높다)
    - memoization, 동적할당을 통해 해결



## 1.2 2. 혈액형 분류하기

여러 사람의 혈액형(A, B, AB, O)에 대한 정보가 담긴 list를 전달 받아, key는 혈액형의 종류, value는 사람 수인 dictionary를 반환하는 count_blood 함수를 작성하시오.

```python
# 1 내가 한 방식
def count_blood(data):
    data_list = ['A', 'B', 'O', 'AB'] # key값 설정
    data_dict = {} # key, value를 담을 공간
    for i in data_list: # data에 담긴 정보를 활용해 딕셔너리에 개수 카운트 추가
        data_dict[i] = data.count(i)
    return data_dict

print(count_blood([
'A', 'B', 'A', 'O', 'AB', 'AB',
'O', 'A', 'B', 'O', 'B', 'AB',
]))

# 2 선생님께서 만든 방식
def count_blood(blood_list):
    blood_dict = {}
    for blood in blood_list:
        if blood_dict.get(blood):
            blood_dict[blood] +=1
        else:
            blood_dict[blood] =1
    return blood_dict
print(count_blood([
'A', 'B', 'A', 'O', 'AB', 'AB',
'O', 'A', 'B', 'O', 'B', 'AB',
]))

# 3 선생님께서 조금 더 수정한 방식
def count_blood(blood_list):
    blood_dict = {}
    for blood in blood_list:
        blood_dict[blood] = blood_dict.get(blood, 0) + 1
    return blood_dict
print(count_blood([
'A', 'B', 'A', 'O', 'AB', 'AB',
'O', 'A', 'B', 'O', 'B', 'AB',
]))
```

## 얕은 복사와 깊은 복사

shallow copy 같은 주소값을 가리킴, deep copy는 다른 주소값을 가리킴

- shallow copy

1. copy.copy()
2. slicing copy
   - mutable을 사용할 때 (list, tuple, dictionary)
     - 메모리를 많이 차지할 수 있어서 주소로 저장
   - immutable은 처음엔 shallow copy지만 변수에 다른 값이 들어오면 새로운 주소를 할당 받는다

```python
s = 'apple'
t = s # t, s는 같은 주소
t = 'banana' #t는 다른 주소로 할당
```

-  shallow copy of nested list(중첩 리스트)

## 06_python_workshop

### 1.1

```python
# 1 나, 선생님 list comprehension
def duplicated_letters(text):
    return list({i for i in text if text.count(i) >= 2})

# 2 선생님
def duplicated_letters(words):
    duplicates = []
    for char in words:
        if words.count(char) >= 2 and (char not in duplicates):
            duplicates.append(char)            
    return duplicates
```

### 1.2

```python
# 1 list comprehension
def low_and_up(word):
    changed_word = [char.upper() if idx % 2 == 1 else char.lower() for idx, char in enumerate(word)]
    return ''.join(changed_word)

print(low_and_up('apple'))

# 2
def low_and_up(word):
    changed_word = ''
    for idx, char in enumerate(word):
        if idx % 2 ==1:
            changed_word = changed_word + char.upper()
        else:
            changed_word = changed_word + char.lower()
    return changed_word
print(low_and_up('apple'))
```

### 1.3

```python
# 1
def lonely(num_list):
    solo_list = [num_list[0]]
    for i in range(1, len(num_list)):
        if num_list[i] != num_list[i-1]:
            solo_list.append(num_list[i])
    return solo_list
print(lonely([1, 1, 3, 3, 0, 1, 1]))
print(lonely([4, 4, 4, 3, 3]))

# 2
def lonely(numbers):
    result = []
    for idx, num in enumerate(numbers):
        if idx == 0:
            result.append(numbers[idx])
        elif result[-1] != num:
            result.append(num)
    return result
print(lonely([1, 1, 3, 3, 0, 1, 1]))
print(lonely([4, 4, 4, 3, 3]))

# 3
def lonely(numbers):
    result = [numbers[0]]
    for num in numbers:
        if result[-1] != num:
            result.append(num)
    return result
```



